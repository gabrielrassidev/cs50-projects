# Week 3 – Algorithms

## Overview
This week introduced core concepts of algorithms, particularly **searching** and **sorting**, as well as the foundational idea of **algorithmic efficiency**. The emphasis was not just on getting the correct output, but on how performance changes based on structure and method.

---

## Topics Covered

### 🔍 Searching Algorithms
- **Linear Search:** Check each item sequentially
- **Binary Search:** Split sorted arrays in half until match is found
- **Insight:** Algorithm choice only matters if the data structure allows it

### 🧮 Sorting Algorithms
- **Bubble Sort:** Compare and swap adjacent items, repeatedly
- **Selection Sort:** Repeatedly select the smallest element and move it
- **Insertion Sort:** Place each new element into its correct sorted position
- **Insight:** All work, but efficiency varies based on input and context

### ⚙️ Algorithm Efficiency
- **Big O Notation:** Measures performance as input size grows
- **Best, Worst, and Average Cases**
- **Scalability and Resource Usage**

---

## Problem Sets Completed

### ✅ `sort.c`
- Implemented and compared bubble, selection, and insertion sort
- Focused on loop structure and swap logic
- Served to visualize step-by-step data manipulation

### ✅ `plurality.c`
- Built a basic election system
- Mapped names to vote counters using arrays and structs
- Handled invalid inputs and ties
- Applied input validation and conditional logic

### 🔜 `runoff.c` *(in progress / upcoming)*
- Ranked-choice voting system
- Requires handling elimination rounds, dynamic re-counting
- Strong exercise in state management and iteration control

---

## Key Takeaways
- The best solution isn’t always about complexity — it’s about **fit**
- Logic is only as good as the structure that supports it
- Edge cases and input validation are as important as the main path
- Efficiency matters early — not just when things scale

---

## Next Up: Week 4 – Memory
- Pointers
- Dynamic memory allocation
- Buffer overflows
- Forensics with image recovery

